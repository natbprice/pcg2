---
title: "tvdiff"
author: "Nathaniel Price"
date: "4/1/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

```{r}
# A method for modifying only select off-diagonal items in a matrix
# From "Thierry" and "Ben Bolker"
# At http://stackoverflow.com/a/11759744/479554

# A sample matrix
size <- 6
mat <- matrix(seq_len(size ^ 2), ncol = size)
print(mat)

# A companion matrix that indicates how "off" a diagonal is:
delta <- row(mat) - col(mat)
print(delta)

# Set these to select on the "delta" matrix
low <- 0
high <- 3

# Operate on the "mat" matrix
mat[delta < low | delta > high] <- NA
print(mat)
```


```{r}
library(cPCG)
library(Matrix)
library(Rlinsolve)
# Load demo data
data("smalldemodata")
data = smalldemodata$obs[1:8]
iter = 1
alph = 0.2
scale = "small"
ep = 1e-6
dx = 0.01
u0 <- NULL

chop <- function(v){
    v[-1]
}

# Get the data size.
n = length(data)

# Default checking. (u0 is done separately within each method.)
if(is.null(dx))   dx = 1.0 / n

# Different methods for small- and large-scale problems.
if (scale == 'small') {

    # Construct differentiation matrix.
    c1 = rep(1, n+1) / dx
    
    
    D <-
      bandSparse(n = n,
                 m = n + 1,
                 c(0, 1),
                 diagonals = matrix(c(-c1, c1), ncol = 2))
    
    DT <- t(D)
    
    # Construct antidifferentiation operator and its adjoint.
    A <- function(x) {
      chop(cumsum(x) - 0.5 * (x + x[1])) * dx
    }

    AT <- function(w) {
      (sum(w) - c(sum(w) / 2.0, cumsum(w) - w / 2.0)) * dx
    }

    # Default initialization is naive derivative

    if (is.null(u0)) {
       u0 <- c(0, diff(data), 0)
    }

    u = u0

    # Since Au( 0 ) = 0, we need to adjust.
    ofst = data[1]
    # Precompute.
    ATb = AT(ofst - data)        # input: size n
    
    # Main loop.
    for (ii in 1:(iter+1)){
      # Diagonal matrix of weights, for linearizing E-L equation.
      Q <- bandSparse(n = n, m = n, k = 0, 
                      diagonals = matrix(1. / sqrt((D %*% u)^2), ncol = 1))
      # Linearized diffusion matrix, also approximation of Hessian.
      L = dx * DT %*% Q %*% D

      # Gradient of functional.
      g = AT(A(u)) + ATb + alph * L %*% u

      # Prepare to solve linear equation.
      # Simple preconditioner.
      # P = alph * sparse.spdiags(L.diagonal() + 1, 0, n + 1, n + 1)
      P <- alph * bandSparse(n = n + 1, m = n + 1, k = 0,
                      diagonals = as.matrix(diag(L) + 1, ncol = 1))

      linop <- function(v) alph * L * v + AT(A(v))
      
      # cgsolve(A, b, float tol = 1e-6, int maxIter = 1000)
      cPCG::pcgsolve(A,
                     b,
                     preconditioner = "Jacobi",
                     tol = 1e-6,
                     maxIter = 1000)
      
      Rlinsolve::lsolve.bicg(
        A,
        B,
        xinit = NA,
        reltol = 1e-05,
        maxiter = 10000,
        preconditioner = diag(ncol(A)),
        verbose = TRUE
      )

      
      cPCG::cgsolve(A, b, tol = 1e-6, maxIter = 1000)
      # linop = splin.LinearOperator((n + 1, n + 1), linop)

      # if diagflag:
      #   [s, info_i] = sparse.linalg.cg(
      #     linop, g, x0=None, tol=tol, maxiter=maxit, callback=None,
      #     M=P)
      # print('iteration {0:4d}: relative change = {1:.3e}, '
      #       'gradient norm = {2:.3e}\n'.format(ii,
      #                                          np.linalg.norm(
      #                                            s[0]) /
      #                                            np.linalg.norm(u),
      #                                          np.linalg.norm(g)))
      # if (info_i > 0):
      #   print("WARNING - convergence to tolerance not achieved!")
      # elif (info_i < 0):
      #   print("WARNING - illegal input or breakdown")
      # else:
      #   [s, info_i] = sparse.linalg.cg(
      #     linop, g, x0=None, tol=tol, maxiter=maxit, callback=None,
      #     M=P)
      # # Update solution.
      # u = u - s
      # # Display plot.
      # if plotflag:
      #   plt.plot(u)
      # plt.show()
    }
}

g
```



```{python}
import numpy as np
import scipy as sp
from scipy import sparse
from scipy.sparse import linalg as splin

# data= [0.494756820948485, 0.458643646800803, 0.495540390492081, 0.427186318780977, 
# 0.443749161202568, 0.413476664984637, 0.435279319963347, 0.47641752033137, 
# 0.447123902054782, 0.457180157725945, 0.344264287747229, 0.388990083596222, 
# 0.320832608989957, 0.379241428537599, 0.366284881611983, 0.404815518427984, 
# 0.3849614741746, 0.352661152437459, 0.28474633063643, 0.276200309650831, 
# 0.187421928908437, 0.257584773103028, 0.192440173256952, 0.306491288923474, 
# 0.295096998592949, 0.246914372452686, 0.211079612074922, 0.227153212869301, 
# 0.290251933321008, 0.267455802714567, 0.167577894432452, 0.188420566046083, 
# 0.113975165249363, 0.180036545378154, 0.186953132235149, 0.185002235231481, 
# 0.0534390863920461, 0.145231039343324, 0.0667892677030525, 0.0811722524006449, 
# 0.129400520252338, 0.0949102820748478, 0.0618129081597573, 0.0903366272767233, 
# 0.131724933945496, 0.00882531378416593, -0.037505008297161, -0.0381120489522528, 
# -0.0372139600715776, -0.0335605469936973, 0.038834058493091, 
# -0.0842885043881021, 0.041798194178902, 0.00107893249998644, 
# 0.104978097269769, 0.017221785218198, 0.0703778811781575, 0.0331207115598942, 
# 0.0559220158745408, 0.0869930284804468, 0.0985602317845594, 0.0937593503005044, 
# 0.186415925737767, 0.167506962476107, 0.242757368034961, 0.146135060273469, 
# 0.223331538543626, 0.0750380574504816, 0.221924188470918, 0.218573272832855, 
# 0.191291035004294, 0.254767416307562, 0.273881437043564, 0.291680282429333, 
# 0.270989566018483, 0.290053461394063, 0.236299084314146, 0.225241077154882, 
# 0.276619163715708, 0.309327518595065, 0.357547233591504, 0.280474063155172, 
# 0.305526100903377, 0.488723693530099, 0.318870732156424, 0.456015149505632, 
# 0.418057446337566, 0.352109841768794, 0.384672242421718, 0.389241937674855, 
# 0.433674484604923, 0.488282047919624, 0.348109814196543, 0.541186443248349, 
# 0.488889464279419, 0.432554903838509, 0.463699431994178, 0.494979020364996, 
# 0.504808559200461, 0.56003914587742]

data= [0.494756820948485, 0.458643646800803, 0.495540390492081, 0.427186318780977, 
0.443749161202568, 0.413476664984637, 0.435279319963347, 0.47641752033137]

itern = 1
alph = 0.2
scale = "small"
ep = 1e-6
dx = 0.01
u0 = None
diagflag = 0
tol = 1e-4
maxit = 100
plotflag = 0

def chop(v):
    return v[1:]
    
# code starts here
# Make sure we have a column vector
data = np.array(data)

# Get the data size.
n = len(data)

# Default checking. (u0 is done separately within each method.)
if dx is None:
    dx = 1.0 / n

# Different methods for small- and large-scale problems.
if (scale.lower() == 'small'):

    # Construct differentiation matrix.
    c = np.ones(n + 1) / dx
    D = sparse.spdiags([-c, c], [0, 1], n, n + 1)

    DT = D.transpose()
    
    # Construct antidifferentiation operator and its adjoint.
    def A(x): return chop(np.cumsum(x) - 0.5 * (x + x[0])) * dx

    def AT(w): return (sum(w) * np.ones(n + 1) -
                           np.transpose(np.concatenate(([sum(w) / 2.0],
                                                        np.cumsum(w) -
                                                        w / 2.0)))) * dx

    # Default initialization is naive derivative

    if u0 is None:
       u0 = np.concatenate(([0], np.diff(data), [0]))

    u = u0
    
    # Since Au( 0 ) = 0, we need to adjust.
    ofst = data[0]
    # Precompute.
    ATb = AT(ofst - data)        # input: size n
    
    # Main loop.
    for ii in range(1, itern+1):
        # Diagonal matrix of weights, for linearizing E-L equation.
        Q = sparse.spdiags(1. / (np.sqrt((D * u)**2 + ep)), 0, n, n)
        # Linearized diffusion matrix, also approximation of Hessian.
        L = dx * DT * Q * D

        # Gradient of functional.
        g = AT(A(u)) + ATb + alph * L * u

        # Prepare to solve linear equation.
        # Simple preconditioner.
        P = alph * sparse.spdiags(L.diagonal() + 1, 0, n + 1, n + 1)

        def linop(v): return (alph * L * v + AT(A(v)))
        linop = splin.LinearOperator((n + 1, n + 1), linop)

        if diagflag:
            [s, info_i] = sparse.linalg.cg(
                linop, g, x0=None, tol=tol, maxiter=maxit, callback=None,
                M=P)
            print('iteration {0:4d}: relative change = {1:.3e}, '
                  'gradient norm = {2:.3e}\n'.format(ii,
                                                     np.linalg.norm(
                                                         s[0]) /
                                                     np.linalg.norm(u),
                                                     np.linalg.norm(g)))
            if (info_i > 0):
                print("WARNING - convergence to tolerance not achieved!")
            elif (info_i < 0):
                print("WARNING - illegal input or breakdown")
        else:
            [s, info_i] = sparse.linalg.cg(
                linop, g, x0=None, tol=tol, maxiter=maxit, callback=None,
                M=P)
        # # Update solution.
        # u = u - s
        # # Display plot.
        # if plotflag:
        #     plt.plot(u)
        #     plt.show()
    
P.todense()
```

